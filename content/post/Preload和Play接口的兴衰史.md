+++
title = "Preload接口和Play接口的兴衰史"
draft = false
date = "2017-06-01"
Categories = ["AkiRoss"] 
Description = "" 
Tags = ["preload","ad"] 
toc = true

+++

通过对业务的深入理解和梳理，来优化架构。先说结论：**Preload的本质是告诉SDK下一次Impression应该展示哪个广告**。


## 背景

对于Native移动视频广告来说，一方面网络条件所限，另一方面要提升用户和广告主的体验，播放广告基本都是以预加载的形式提前把广告加载完成。这个特性让Ad Serving的流程大大不同。

## 第一版的做法
### 提供了两个接口:
1. Preload,用来告诉SDK有哪些广告可以下载，然后告诉SDK开始下载，一般是三到五条。
2. Play，在SDK有曝光机会的时候，SDK将已经预加载完成的广告告诉Server，Server从中挑出可播的广告。

### 问题
1. Preload和Play两个接口时间上有间隔，在另一个时间点，各种条件已经变化了，需要重新挑选广告。所以同一次曝光机会，可能需要挑选两次。
2. Play接口的响应时间要求很高，客户端的网络又不稳定。
3. 整个链路太长，又有些条件不可控，所以Ad Serving的逻辑很难优化。


## 梳理业务，重新定义

### 其他部门角度
1. 对商务来说，尾量可以接受，甚至非常正常。这意味着，各种定向控制并不需要那么严谨。
2. 对运营来说，CDN的消耗相比转化率的提高并不重要，更迫切需要一个可以快速干扰Ranking的办法。
3. 对产品来说，需要让事情简单化。我们的Preload的挑选广告就对应传统Ad产品中的那次挑选广告就OK。
4. 对数据来说，填充率的计算需要和流量方匹配。对应第一版来说，填充率，是用Play接口的成功返回/Play接口的调用。
5. 对技术来说，Play接口要求太高，优化起来太困难。

### 那么
1. Preload接口挑选广告，Play接口只做Impression的上报
2. 激进的来说，每次Preload只预加载一次，播完就删
3. 在应用启动和每次播放完成之后调用一次Preload

Play的逻辑前置和合并到Preload里面，Play沦为一个上报接口


## 推而广之

SDK模式下，每个接口对userId是否是合法用户的检查也没有意义。

所谓SDK模式，因为SDK是自家的，流量和费用都是通过商务谈的。API的设计是建立在SDK可控和可以信任的基础之上的。现有架构之下，每次激活相当于获得了一个调用其他API的Token，而这个Token是保存在客户端本地的，所以，没必要去单独Check UserId，
即使检查不通过，SDK自动会去调用用户激活接口，又会得到一个已经激活UserId。